-- 대용량데이터 / 정규화 / 반정규화 / 분산데이터베이스
-- 오라클로 연결
SELECT * FROM TBL_MOVIE 

-- 성능 데이터 모델링? 데이터 모델링의 성능을 높이는게 목적
-- 데이터 모델링? 데이터베이스(테이블, PK, FK, 관계 설정, 조인, ...) 설계

-- 성능 향상을 위한 비용은 프로젝트 수행 중에 있어서 사전에 할수록 비용이 들지 않는다.

-- 특히 분석/설계 단계에서 데이터 모델에 성능을
-- 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무(Rework)
-- 비용을 최소화 할 수 있는 기회를 가지게 된다.

-- 분석/설계단계에서 데이터 모델은 대충하고, 
-- 성능이 저하되는 SQL문장을 튜닝하고, 부족한 하드웨어 용량(CPU, Memory 등)을 증설하는 등의 작업은
-- 추가적인 비용을 소진하게 하는 원인이 된다. 

-- 특히 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 기하급수적으로 증가하게 된다.

-- 병렬처리

-- 성능 데이터 모델링 고려사항
-- ① 데이터 모델링을 할 때 정규화(중복 최소화)를 정확하게 수행한다.
-- ② 데이터베이스 용량산정을 수행한다. -> 용량산정? 미리 계산
-- ③ 데이터베이스에 발생되는 트랜잭션(논리적인 단위)의 유형을 파악한다.
-- INSERT/UPDATE/DELETE VS SELECT
-- 테이블에 있는 데이터를 자주 변경할 경우?

-- ④ 용량과 트랜잭션의 유형에 따라 반정규화(정규화의 반대)를 수행한다.
-- 테이블을 분리해주는게 빠르냐? VS 하나로 합쳐서 보여주는게 빠르냐? 의 차이
-- SELECT(더 빠름) - 테이블 1개  VS  SELECT+JOIN (최소 2개이상 테이블) (더 느림)

-- ⑤ 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.
-- ⑥ 성능(비용)관점에서 데이터 모델을 검증한다.


-- 초기 설계가 성능에 미치는 영향
-- BULK? 대용량으로 데이터를 추가한다.(1000개, 1만개, 10만개,...)
DROP TABLE TBL_BULK_TEST

CREATE TABLE TBL_BULK_TEST
(
ID NUMBER GENERATED ALWAYS AS IDENTITY, -- 자동으로 ID 번호를 1씩 증가시킴(ORACLE에서 사용되며, SQLD에서 INCREMENT와 동일 기능)
current_time date
)
INSERT INTO TBL_BULK_TEST(current_time) VALUES(SYSDATE)

SELECT * FROM TBL_BULK_TEST

-- NUM1 변수? 데이터 저장하는 장소
-- NUM1에다가 1을 저장해라.
DECLARE
NUM1 NUMBER :=1;
BEGIN
    LOOP
    DBMS_OUTPUT.PUT_LINE(NUM1); --출력
    NUM1 := NUM1+1; --NUM = NUM +1
    INSERT INTO tbl_bulk_test(current_time) values(SYSDATE);
    EXIT WHEN NUM1 >10; --NUM1이 10보다 크면 LOOP종료
    END LOOP;
END;


-- TO_CHAR
SELECT to_char(current_time,'YYYY/MM/DD HH24:MI:SS'),
current_time 
FROM tbl_bulk_test
WHERE to_char(current_time,'HH24')='09'


-- 데이터베이스 DBA / 프로그래머

-- 하나의 테이블에 대량의 데이터가 존재하는 경우에는 인덱스의 Tree구조가 너무 커져 효율성이 떨어져
-- 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O(데이터 저장/출력하는 행위)를 많이 유발하게 된다

-- 또한 한 테이블에 많은 수의 칼럼이 존재하게 되면 데이터가 디스크의 
-- 여러 블록에 존재하므로 인해 디스크에서 데이터를 읽는 I/O량이 많아지게 되어 성능이 저하되게 된다.
-- 대량의 데이터가 처리되는 테이블에 성능이 저하되는 이유는 SQL문장에서 데이터를 처리하기 위한 I/O의 양이 증가하기 때문이다.

-- PRIMARY KEY - 주키 / 테이블에서 무조건 하나밖에 없다. 무조건 정렬을 해줘야 함

-- PK가 없을경우엔 입력순으로 입력되지만, PK가 있을경우엔 번호순으로 입력된다. 


-- 분산 데이터베이스와 성능
-- 분산 데이터베이스? 하나의 데이터베이스 관리 시스템이 여러 CPU에 연결된 저장장치들을 제어하는 형태의 데이터베이스.
-- 사용자 입장에서는 데이터베이스 1개인지? 10개인지? 모름..

-- mssql replication(복제) - 복제를 통해서 분산 데이터베이스를 구성 가능
-- 물리적으로는 분리되나, 논리적으로는 1개이다.

				  -- 서울(네이버 제1 데이터센터) - 홍길동 (카페 글쓰기)
-- 사용자(naver) ---|
				  -- 부산(네이버 제2 데이터센터) - 김철수


-- 분산 데이터베이스의 투명성(Transparency)
-- 분산데이터베이스가 되기 위해서는 6가지 투명성(Transparency)을 만족해야 한다.

-- 1) 분할 투명성 (단편화) : 하나의 논리적 Relation(테이블)이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
-- 2) 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요. 위치정보가 System Catalog(시스템 정보들을 모아놓은 장소)에 유지되어야 함
-- 3) 지역사상 투명성 : 지역DBMS와 물리적 DB사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용 가능
-- 4) 중복 투명성 : DB 객체가 여러 site에 중복 되어 있는지 알 필요가 없는 성질
-- 5) 장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 Transaction의 원자성 유지
-- 6) 병행 투명성 : 다수 Transaction 동시 수행시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현


-- 일반적인 SELECT
-- 튜닝을 한 SELECT -> SELECT ...(튜닝)

-- 다음 중 성능 데이터모델링에 대한 설명으로 가장 부적절한 것은? 1번
-- ① 성능이 저하된 결과를 대상으로 데이터 모델 보다는 문제발생 시점이 SQL을 중심으로 집중하여 튜닝을 한다. 
	-- -> 데이터 모델링을 바꾼다거나(뼈대)  vs SQL 튜닝(외관-페인트칠)

-- ② 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가한다. 
-- ③ 데이터 모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다. 
-- ④ 분석 / 설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework 비용을 최소화 할 수 있는 기회를 가지게 된다.


-- 분산처리 : 같은 일을 여러개의 컴퓨터한테 시키는것
-- 병렬 : 하나의 컴퓨터 내에서 여러개의 CPU한테 일을 시키는 것
-- CPU ? 일꾼 (스타크래프트에 SCV)


-- 정규화 : 데이터베이스의 설계에서 중복을 최소화 할 수 있도록 하는 것.

						---> 정규화 실행
테이블 A(영화)(+회원정보)						테이블 A(영화)						
테이블 B(예매)(+회원정보)						테이블 B(예매)
테이블 C(리뷰)(+회원정보)						테이블 C(리뷰)
										테이블 D(리뷰)(회원정보)

-- 정규화 목적 
-- 1. 불필요한 데이터를 제거(중복 최소화)
-- 2. 다양한 관점에서의 QUERY 를 지원(조인)
-- 3. 각종 이상 현상(Anomaly) 을 방지하기 위해서

-- 비정규 릴레이션 -> 1NF(FIRST NORMAL FORM) -> 도메인이 원자값을 만족한다.
-- 도메인이 원자값(쪼개지면 안됨)을 만족하지 않는 것 -> 비정규 릴레이션
-- PHONE_NUMBER 는 속성이고 도메인은 PHONE_NUMBER가 가질수 있는 범위								

WITH customer as(										
SELECT 1 id, 'john' name, '555-1234, 343-1234' PHONE_NUMBER FROM DUAL 
UNION ALL
SELECT 2 id, 'sam' name, '555-5678' PHONE_NUMBER FROM DUAL
UNION ALL
SELECT 3 id, 'jane' name, '777-1234' PHONE_NUMBER FROM DUAL
) SELECT * FROM customer

ID	NAME	PHONE_NUMBER
1	john	555-1234, 343-1234
2	sam		555-5678
3	jane	777-1234


WITH customer as(										
SELECT 1 id, 'john' name, '555-1234' PHONE_NUMBER, 
	'434-1234' PHONE_NUMBER2 FROM DUAL 
UNION ALL
SELECT 2 id, 'sam' name, '555-5678' PHONE_NUMBER,
	'' PHONE_NUMBER2 FROM DUAL 
UNION ALL
SELECT 3 id, 'jane' name, '777-1234' PHONE_NUMBER, 
	'' PHONE_NUMBER2 FROM DUAL 
) SELECT * FROM customer
--> 전화번호가 늘어날때마다 컬럼을 추가해줘야 함

ID	NAME	PHONE_NUMBER	PHONE_NUMBER2
1	john	555-1234		434-1234
2	sam		555-5678		NULL
3	jane	777-1234		NULL


보통 정규화가 많이 일어날수록 테이블은 많아진다. -> 조인도 많아진다.
반정규화를 많이 할수록 테이블은 적어진다. -> 조인도 적어진다.


-- 반정규화(역정규화) : 정규화 반대로 진행
-- 비정규화 : 아예 정규화를 수행하지 않은 모델을 지칭할때 사용
-- 반정규화는 데이터의 중복(데이터의 통합,중복,분리)을 통해서 성능을 향상시키는 것.
-- 정규화를 통해서 데이터의 중복을 최소화

-- 반정규화의 순서(중복을 허용한다 / 테이블을 늘린다.)
/*
 * 1. 반정규화의 대상을 조사(데이터의 양, 프로세스 등)
 * 2. 자주 사용되는 테이블에 접근하고 항상 일정한 범위만을 조회하는 경우에 반정규화를 검토한다.
 * 3. 테이블에 대량의 데이터가 있고, 대량의 데이터 범위를 자주 처리하는 경우 반정규화를 검토
 * 4. 통계성 프로세스의 의해서 통계 정보를 만들때 반정규화 함.
 * 통계성 테이블? 통계란?
 * 영화 테이블(개인 정보, 영화 정보, 예매 정보, ....) -> 통계 테이블
 * 통계라는 것은? 기존 정보를 활용해서 추천해주는 시스템을 만들때 통계 사용 가능
 * 
 * 5. 테이블에 지나치게 많은 조인이 걸린 작업을 줄일 수 있다. 
 * 
 */

-- 반정규화의 기법(중복을 허용)
-- 1. 테이블 병합(테이블을 합친다)
-- 조인되는 경우가 많아서 테이블을 합치는 것이 성능향상에 도움이 될 때. -> 조인할 필요 없어짐

-- 2. 테이블 분할
-- 테이블에서 특정 속성들만 집중적으로 접근할 경우 분할
-- 2.1 : 수직 분할 : 특정 속성들만 접근이 잦을 경우 쪼갠다.
-- 2.2 : 수평 분할 : 카페 참고 - 연도별 이력 조회

-- 3. 테이블 추가
 -- 중복테이블
 -- 통계테이블
 -- 이력테이블
 -- 부분테이블

 -- 이력테이블? 
 -- 출석 체크(테이블에 저장)

-- 4. 중복 컬럼 추가


문제.특정 테이블에서 사원칼럼, 부서칼럼만 추출하는 경우에 DISK I/O를 경감할 수 있는 반정규화 방법은 무엇인가? 2번
1) 수평 분할
2) 수직 분할
3) 중복 테이블 추가
4) 수직 및 수평 분할 수행












